![](Logo_Git.png)
# 1. Начало работы с Git

## ***1.1. Проверка наличия установленного Git***

В терминале выполнить корманду `Git --version`.
Если Git установлен, то выйдет информация об установленной версии программы, иначе появится сообщение об ошибке.
## ***1.2. Установка Git***

Установить последнюю версию программы с сайта https://git-scm.com/downloads.
Устанавливаем с настройками по умолчанию.

После установки можно узнать имя версии Git с помощью команды обращения к программе Git:
```
git version
```
команды обращение к терминалу:
```
git --version
```
## ***1.3. Настройка Git***

При первом использовании Git нужно представиться. Для этого в терминале или программе Git нужно ввести две команды: 
```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```
Проверить корректность представления можно введя команду:
```
git config --global --list
```
## ***1.4. Инициализация локального репозитория***
Чтобы создать новый репозиторий, нужно открыть нужную папку и в терминале ввести команду:
```
git init
```
## ***1.5. Проверка состояния репозитория***
Важная команда показывает информацию о текущем состоянии репозитория (актуальность, что появилось нового, наличие незафиксированных изменений, прочее):
```
git status
```
## ***1.6. Запись изменений одного файла из папки в репозиторий***
**`Коммит`** - снимок состояния репозитория.

Добавление к отслеживанию/подготовка к фиксации **определенного файла** из папки:
```
git add <file name>
```
После подготовки к фиксации оставляем непосредственно сам комментарий к коммиту:
```
git commit -m "Комментарий"
```
## ***1.7. Запись истории т всех файлов из папки сразу в репозиторий***
Если мы хотим отслеживать **все файлы** находящиеся в данной папке, то используем команду:
```
git add -A
```
В дальнейше для подготовки к фиксации используем команду:
```
git add .
```
Далее нужно внести комментарий при помощи команды `git commit`. Но можно сразу сохранить коммит/произвести фиксацию состояния **всех файлов из папки** и записать комментарий к нему при помощи команды:
```
git commit -a -m "Комментарий"
```
Изъять ненужный файл из отслеживания:
```
git reset <file name>
```
## ***1.8. Отмена сохранения до коммита***
Бывает, что вы поторопились и внесли не все изменения которые должны попасть в коммит, и вы это вспомнили после того как выполнили команду `git add`, но до выполнения компанды `git commit`, тогды мы можем воспользоваться команда отмены добавления к сохранению:
```
git restore <file>
```
## ***1.9. Внесение изменений в последний коммит***
Вы ошиблись в тексте комментария к последнему коммиту или сам коммит был с ошибкой, то эта команда поможет его отредактировать с изменением индекса коммита. Или же вы можете изменить коммит без изменения комментария:
```
git commit --amend
```
После выполнения данной команды откроется встроенный редатор (например, Vim). В нем нужно скорректитировать последний комментарий. Затем нажать `Escape`, `i`, `Escape` и набираем  в последней строке `:wq`.

Другой способ сделать это без открытия текстового редактора:
```
git commit --amend -m "Новый комментарий"
```
***Эти команды лучше не использовать при работе с публичными репозиториями.***

## ***1.10. Просмотр истории коммитов***
Вывод на экран истории коммитов (развёрнуто):
```
git log
```
Вывод истории коммитов (одной строкой):
```
git log --oneline
```
## ***1.11. Удаление коммита***
Удалить последний коммит можно очень просто с помощью команды `git reset`. Причём можно это сделать сохранив изменения в рабочей директории. Например, удаляем 1 последний коммит, но изменения оставляем:
```
git reset HEAD~1
```
Или же можно это сделать полностью удалив все изменения сделанные в последнем/их коммите/ах. Например, удаляем 2 последний коммита и изменения также :
```
git reset --hard HEAD~2
```
***Команда `git reset` лучше использовать только для непубличных репозиториев.***

А вот отменить изменения сделанные в последнем коммите можно с помощью команды `git revert`. Она делает еще один коммит, но с противоположными изменениями:
```
git revert HEAD --no-edit
```
***Этот способ подходит для работы с публичными репозиториями.***

## ***1.12. Просмотр разницы между коммитами***
Чтобы увидеть разницы между двумя определенными коммитами нужно выполнить команду:
```
git diff <ID commit1>..<ID commit2>
```
Изменения между двумя последними коммитами:
```
git diff
```
Изменения между подготовленным  / ID-файлом и последним коммитом:
```
git diff --cached
```
## ***1.13. Перемещение между коммитами***
Для переключения на нужный коммит выполняем команду. После переключения, все файлы в проекте станут такими, какими они были в данном коммите:
```
git сheckout <ID commit>
```
Из текущего местоположения вернуться на главную ветку поможет команда:
```
git checkout master
```
## ***1.14. Игнорирование файлов***
Принято в отслеживание добавлять только текстовые файлы, а большие файлы, например, картинки нет. В удаленных репозиториях вместо файлов принято использовать (относительные) ссылки.
В папку копируем файл-картинку, потом в папке создаем файл ` .gitignore `.

Открываем созданный файл и записываем в него название файла-картинки с расширением или шаблоны файлов подлежащих игнорированию.

Все файлы записанные в `.gitignore` автоматически игнорируются. Цвет игнорируемых файлов - серый.

После этого обязательно записать коммит о дабавлении файла-игнора.
# 2. Работа с ветками
## ***2.1. Создание веток***
Ветка в Git (черновой проект) - это простой перемещаемый указатель на один из коммитов, обычно последний в цепочке коммитов. Перемещаемый указатель - `HEAD`.

По умолчанию название основной ветки (чистовой прокт) - `master`.

Cоздание новой ветки производится с использованием команды:
```
git branch <new branch>
```
## ***2.2. Изменение имени текущей ветки***
Изменить название текущей ветки можно с помощью команды:
```
git branche -m <new branch name>
```
## ***2.3. Перемещение между ветками***
Данная команда аналогичка команде перемещения между коммитами:
```
git checkout <branch name>
```
Альтернативная команда:
```
git switch <branch name>
```
Комбинированная команда по созданию ветки и перемещению в нее:
```
git checkout -b <new branch>
```
## ***2.4. Cлияние веток без конфликтов***
Перед слиянием нужно убедиться, что вы зафиксировали коммиты в обоих ветках сливаемой и той куда происходит слияние.

Затем нужно перейти в ветку, куда будет производиться слияние и только тогда выполнить команду:
```
git merge <branch name>
```
Тут могут возникнуть две ситуации: слияние с конфликтом и без.
При слиянии без конфлитка команда будет выполнена без каких либо заметок.

Не забудьте закоммитить слияние.
## ***2.5. Слияние веток с конфликтами***
В случае, если в одном и том же пункте в разных ветках были выполнены разные редакции - то слияние пройдет с конфликтом. При этом программа вам предложит выбрать один из вариантов слиянияпше:
+ Accept Current Change
+ Accept Incomming Change
+ Accept Both Changes
+ Compare Changes

Можете выбрать один из вариантов разрешения конфликтов, а также после доработать вручную.

Не забудьте закоммитить слияние.
## ***2.6. Удаление веток***
Хорошим тоном является чистка истории от уже ненужных веток, например, слитых.
Удаление слитой ветки (все изменения ветки перенесены на 100% в другую):
```
git branch -d <branch name>
```
Удаление неполностью слитой ветки (есть изменения, которые вы решили не переносить в чистовой проект):
```
git branch -D <branch name>
```
# 3. Работа с удалёнными репозиториями
## ***3.1. Клонирование удаленного репозитория***
Для копирования удаленного репозитория нет необходимости создавать аккаунт на Github (` github.com `). Достаточно выбрать нужный репозиторий и нажав зелёную кнопку  ` Code ` скопировать путь ` https://.
![](Image_CopyCode.png)

Далее в ` VScode`  создаем папку, убеждаемся что в данной папке отсутствует репозиторий и если это так, то при помощи следующей команды создаем копию нужного репозитория на локальном устройстве:
```
git сlone https://github.com/.../...git
```
Если мы хотим скопировать репозиторий под новым именем, то мы в конце команды добавляем новое имя:
```
git сlone https://github.com/.../...git <new name>
```
После выполнения команды внутри ранее созданной папки создается папка, содержащая рабочую копию последней версии удалённого репозитория. Имя этой папки аналогично имени выбранного на GitHub удалённого репозитория. 
При клонировании репозитория, как правило, автоматически создаётся ветка master, которая следит за origin/master.
Однако, при желании вы можете настроить отслеживание и других веток::
```
git checkout --track origin/<branch name>
```
Для дальнейшей работы перемещаемся во вновь созданную папку  по команде:
```
cd <name new folder>
```
Для того, чтобы клонировать репозиторий в каталог с именем, отличающимся от имени существующего на GitHub, необходимо указать желаемое имя после команды:
```
git сlone https://github.com/.../...git <name new folder>
```
## ***3.2. Просмотр подключений к удалённым репозиториям***
Проверка наличия привязки к удалённому репозиторию:
```
git remote
```
При помощи данной команды можно вызвать список удаленных подключений к удалённым репозиториям с именами и соответствующими URL-адресами:
```
git remote -v
```
## ***3.3. Переименование удалённого репозитория***
Вы решили переименовать удалённый репозиторий, тогда изначально откройте нужный принадлежащий вам репозиторий, откройте вкладку ` Settings `, затем  введите новой имя и жмите` Rename `.

Следующим шагом нужно переподключить вам локальный репозиторий к переименоманному удаленному репозиторию по протоколу HTTPS, вводим команду:
```
git remote set-url origin https://github.com/.../<new name remote repository>.git
```
## ***3.4. Удаление подключения к удалённому репозиторию***
Для удаления подлкючения к определенному удалённому репозиторию, заходить в нужную локальную директорию, и выполняем команду:
```
git remote rm <name remote repository>.git
```
## ***3.5. Стирание удаленной ветки***
Иногда ветки необходимо чистить для наведения порядка. Чтобы полностью стереть ветку, ее необходимо стереть как в локальном репозитории, так и в удаленном.
```
git branch -D branch_name
git push --delete origin <remote_branch name>
```
Первая команда сотрет локальную ветку с именем branch_name. После выполнения сторой будет стерта удаленная ветка.
## ***3.6. Извлечение содержимого из удалённого репозитория (безопасный вариант)***
Ясно, что предварительно нужно настроить подключение к удалённому репозиторию. Команда ` git fetch ` загружает коммиты, файлы и ссылки из удаленного репозитория в ваш локальный репозиторий, но не делает попыток слияния:
```
git fetch origin
```
Извлеченное содержимое в Git остается изолированным от имеющихся локальных данных и совершенно не влияет на локальную разработку. 

После можно проверить обновленные удаленные ветки:
```
git branch -r
```
Извлеченные ветки будут выведены как ` origin/<branch name> `.

Теперь сравним локальную ветку с обновленной удаленной веткой, чтобы увидеть различия:
```
git diff origin/master
```
Также можно посмотреть историю коммитов обновленной удаленной ветки:
```
git log origin/master
```
Таким образом, вы можете просмотреть коммиты из удалённого репозитория, перед тем как интегрировать их в локальную версию.

Переключимся на обновленную удаленную ветку:
```
git checkout origin/master
```
Cольем изменения из обновленной удаленной ветки в нашу локальную ветку:
```
git merge origin/master
```
Если необходимо обновить только одну ветку, например, master, не задействуя остальные доступные ветки в удаленном репозитории, то нужно выполнить следующую команду: 
```
git fetch origin master
```
## ***3.7. Извлечение содержимого из удалённого репозитория (принудительный вариант)***
При использовании ` pull `, Git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.

` Git pull ` — это шоткод для последовательности двух команд: ` git fetch ` и ` git merge `.

## ***3.8. Создание бесплатного удалённого репозитория на GitHub и помещение конфигурации в него (заливка из локального)***
Вам нужно отправить локальный репозиторий на один из удалённых сервисов, например, GitHub. Для этого, **первым шагом**, нужно зарегистрируем свой аккаунт на данном сервисе. **Вторым**, создаем новый репозиторий на GitHub одним из способом:
+ нажимаем ` + ` в правом верхнем углу, далее ` New repository `;
+ нажимаем зеленую кнопку ` New ` в левом верхнем углу.

Заполняем основные свойства будущего репозитория:
+ задаем имя вашего будущего репозитория;
+ ставим / не ставим флажок Initialize this repository with a README, чтобы в дальнейшем вы имели возможность сразу клонировать репозиторий на свой компьютер;
+ выбираем Private/Pablic;
+ выбираем нужен / не нужено подгружать файлы включенные в ` .gitignore `;
+ жмём ` Create repository `. 

Удаленный пустой репозиторий  создан. Открыта страница с подсказками, что делать дальше. Тут предлагаются три способа дальнейшего создания репозитория, например, выбираем 2-й: заливаем локальный репозиторий с новым файлом `Readme.md`.

**И третьим шагом**: открываем локальный репозиторий, удостоверяемся, что сохранены и закоммичены все последние изменения в копируемом локальном репозитории, и только после этого последовательно выполняем три команды из предложенных на :
```
git remote add origin https://github.com/.../...git -  отправка изменений в чистый репозиторий
git branch -M mainи - изменения принимаются в главную ветку
git push -u origin main - пушить надо на сервер origin ветку под именем master:
```
## ***3.9. Отправка изменений на сервер/удалённый репозиторий по умолчанию***
В последующем процесс отправки обновленного состояния локального репозитория на Github упрощается до одной команды.
Но сначала проверяется актуальность вашей локальной основной ветки. Для этого извлекается копия центрального репозитория, после чего поверх нее перебазируются ваши изменения. Кстати, с помощью интерактивного перебазирования можно удобно очистить коммиты перед тем, как делиться ими:
```
git checkout main
git fetch origin main
git rebase -i origin/main 
```
Затем все коммиты вашей локальной основной ветки отправляются в центральный репозиторий:
```
git push
```
Обязательно перед отправкой зафиксируйте все изменения.
Отправка ветки на сервер в ветку с другим именем выполняется по команде:
```
git push origin branch:server_branch
```
где ` branch ` – имя локальной ветки, ` server_branch ` – имя удаленной ветки на сервере.

Отправка всех веток на сервер/удалённый репозиторий:
```
git push origin --all
```
Отправка текущей ветки с тем же именем на сервере.
```
git push origin HEAD 
```
HEAD указывает на текущую ветку (current branch). Тем самым, не надо запоминать имя ветки, на которой вы находитесь.
## ***3.10. Принудительная отправка изменений на сервер/удалённый репозиторий при исправлении коммитов***
Команда ` git commit ` имеет параметр ` --amend `, который позволяет обновить предыдущий коммит. В коммиты часто вносятся исправления, чтобы обновить комментарий к коммиту или добавить новые изменения. Если коммит был исправлен, то при выполнении команды ` git push ` произойдет сбой, так как Git воспримет исправленный коммит и коммит в удаленном репозитории как отличающееся содержимое. Параметр ` --force ` позволит выполнить команду push и опубликовать измененный коммит принудительно:
``` 
git push --force origin main
```
# 4.  Участие в проекте с открытым исходным кодом
` Fork `- полная копия удалённого репозитория, в переводе с английского "вилка".

` Open Space Code `- проект с открытым исходным кодом. 

Открытый исходный код – это децентрализованная модель разработки, которая позволяет любому человеку изменять технологию и обмениваться ею, поскольку ее структура находится в открытом доступе. 
Шаги по участию в проекте с открытым исходным кодом
1. Открываем интересующий нас проект, в верхнем правом углу наживаем кнопку ` Fork `. Как результат на нашем аккаунте появляется полная копия данного проекта.

2. Клонируем форкнутый проект к себе в локальную версию.

3. Переходим в локальную версию и создаем свою ветку и все изменения производим там. Также важно - создаем файл README.md, где оставляем описание наших предложений.

4. Вносим изменения, фиксируем коммитами.

5. Отправляем/заливаем наши изменения на свой аккаунт:
``` 
git push
git push --set -upstream origin <remote_branch name>
```
Как результат у удолённого репозитория должна появиться новая ветка. А также кнопка ` Compare&Pull request `.

6. Жмём кнопку ` Compare&Pull request `. Открывается окно ~ open a pull request `. В открытое поле записываем описание/заголовок к предложениям.
7. Жмём ` Create pull request `.
8. Дальше очередь автора принять или не принять предложенные изменения.

# 5. Сдача домашнего задания
## Репозиторий для **pull request**
* В своём аккаунте на GitHub создать копию репозитория **"AndreyBulgakov19/SCV_Git_0223"** с помощью кнопки **"Fork"**.
---
* Клонировать копию репозитория на локальный компьютер.
---
* Создать новую ветку.
---
* Добавить файл с инструкцией в новую ветку.
---
* Дополнить инструкцию разделами по работе с удалёнными репозиториями, pull request.
---
* Зафиксировать изменения (коммиты).
---
* Отправить изменения на GitHub.
---
* На сайте GitHub выполнить **Pull request**.
---
